package algo

import (
    . "../structs"
    "../util"
    "strings"
)

// Performs local alignment in full matrix area generated by given SeqPair.
// AlignResult returned by this function recovers align.
// Uses dynamic programming approach.
func SmithWatermanFull(seqPair *SeqPair, wm *WeightMatrix, gapPenalty int) *AlignResult {
    dp := make([][]int, len(seqPair.S1) + 1)

    for i := range dp {
        dp[i] = make([]int, len(seqPair.S2) + 1)
    }

    maxScore := 0
    maxPos   := Point{}

    // Main part

    for row := 0; row < len(seqPair.S1); row += 1 {
        for col := 0; col < len(seqPair.S2); col += 1 {
            // dp indices are actually (row + 1, col + 1) because of dummy zero-indexed elements
            dp[row + 1][col + 1] = util.Max4(
                0,
                dp[row + 1][col] + gapPenalty,                     /* left */
                dp[row][col + 1] + gapPenalty,                     /* top */
                dp[row][col]     + seqPair.WeightIn(wm, row, col)) /* top-left */

            if maxScore < dp[row + 1][col + 1] {
                maxScore = dp[row + 1][col + 1]
                maxPos = Point{ col + 1, row + 1 }
            }
        }
    }

    //fmt.Println("TABLE:")
    //for i, lst := range dp[1:] {
    //    fmt.Printf("%-2v: %-3v\n", i, lst)
    //}
    //fmt.Println()

    // Recovery

    s1Builder := strings.Builder{}
    s2Builder := strings.Builder{}

    curPos := maxPos

    if curPos.X > 0 {
        for i := len(seqPair.S2) - 1; i > curPos.X - 1; i -= 1 {
            s1Builder.WriteByte('-')
            s2Builder.WriteByte(seqPair.S2[i])
        }
    }

    if curPos.Y > 0 {
        for i := len(seqPair.S1) - 1; i > curPos.Y - 1; i -= 1 {
            s1Builder.WriteByte(seqPair.S1[i])
            s2Builder.WriteByte('-')
        }
    }

    for curPos.X > 0 && curPos.Y > 0 {
        l  := dp[curPos.Y][curPos.X - 1]     + gapPenalty                                       /* left */
        t  := dp[curPos.Y - 1][curPos.X]     + gapPenalty                                       /* top */
        tl := dp[curPos.Y - 1][curPos.X - 1] + seqPair.WeightIn(wm, curPos.Y - 1, curPos.X - 1) /* top-left */

        max := util.Max4(0, l, t, tl)

        if max == 0 {
            break
        } else if max == l {
            s1Builder.WriteByte('-')
            s2Builder.WriteByte(seqPair.S2[curPos.X - 1])
            curPos.X -= 1
        } else if max == t {
            s1Builder.WriteByte(seqPair.S1[curPos.Y - 1])
            s2Builder.WriteByte('-')
            curPos.Y -= 1
        } else { /* max == tl */
            s1Builder.WriteByte(seqPair.S1[curPos.Y - 1])
            s2Builder.WriteByte(seqPair.S2[curPos.X - 1])
            curPos.X -= 1
            curPos.Y -= 1
        }
    }

    for curPos.X > 0 {
        s1Builder.WriteByte('-')
        s2Builder.WriteByte(seqPair.S2[curPos.X - 1])
        curPos.X -= 1
    }

    for curPos.Y > 0 {
        s1Builder.WriteByte(seqPair.S1[curPos.Y - 1])
        s2Builder.WriteByte('-')
        curPos.Y -= 1
    }

    s1Align := util.ReverseString(s1Builder.String())
    s2Align := util.ReverseString(s2Builder.String())

    s1AlignColored := strings.Builder{}
    s2AlignColored := strings.Builder{}

    for i := range s1Align {
        if s1Align[i] == '-' {
            s1AlignColored.WriteString(util.Colorify("-", util.ColorBlue))
            s2AlignColored.WriteByte(s2Align[i])
        } else if s2Align[i] == '-' {
            s1AlignColored.WriteByte(s1Align[i])
            s2AlignColored.WriteString(util.Colorify("-", util.ColorBlue))
        } else if s1Align[i] == s2Align[i] {
            s1AlignColored.WriteString(util.Colorify(string(s1Align[i]), util.ColorGreen))
            s2AlignColored.WriteString(util.Colorify(string(s2Align[i]), util.ColorGreen))
        } else {
            s1AlignColored.WriteString(util.Colorify(string(s1Align[i]), util.ColorRed))
            s2AlignColored.WriteString(util.Colorify(string(s2Align[i]), util.ColorRed))
        }
    }

    // Return result
    return &AlignResult{
        Score: maxScore,
        Align: s1AlignColored.String() + "\n" + s2AlignColored.String(),
    }
}
