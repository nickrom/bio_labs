package algo

import (
    . "../structs"
    "../util"
)

// Performs local alignment in strip-bounded area of matrix generated by given SeqPair.
// AlignResult returned by this function does not recover align.
// Uses dynamic programming approach.
func SmithWatermanStrip(seqPair *SeqPair, strip Strip, wm *WeightMatrix, gapPenalty int) *AlignResult {

    // Algorithm is divided into three steps.
    // First step  is calculation of area between strip start (left-top) and uniform area.
    // Second step is calculation of uniform area (with parallelogram form).
    // Third step  is calculation of area between uniform area and strip end (right-bottom).

    //  s1\s2  A1   A2   A3   A4   A5   A6   A7  ...  AM-1  AM
    //   B1    *    *   <-- step 1
    //   B2    *         *
    //   B3    * - - - - - - -*
    //   B4         *              *   <-- step 2
    //   B5              *              *
    //   B6                   *              *
    //   B7                        *              *
    //   ...                            *              *
    //  BN-1                                 * - - - - - - -*
    //   BN                                       *    *    *   <-- step 3

    // Pre-initializations

    l := int(strip.Left)
    r := int(strip.Right)
    w := r - l + 1 /* strip width */

    dpB := make([]int, w + 2) /* Backward running line of dynamic programming pass */
    dpF := make([]int, w + 1) /* Forward  running line of dynamic programming pass */

    // After row processing (for step one):
    //   i   |   0    1    2    3    4    ...   N = w
    //  dpB  |   0    x1   x2   x3   x4   ...   xN
    //           |    |    |    |    |          |
    //  dpF  |   0    x1   x2   x3   x4   ...   xN

    // After row processing (for steps two and three):
    //   i   |   0    1    2    3    4    ...  N+1 = w+1
    //  dpB  |   x1   x2   x3   x4   x5   ...   0
    //              \    \    \    \          \
    //  dpF  |   0    x1   x2   x3   x4   ...   xN

    maxScore := 0

    /* ---===---  First step  ---===--- */

    startRow      := util.MaxInt(0, -r)
    endRow        := util.MaxInt(0, -l - 1) /* Assume l < 0, otherwise loop will be trivial (with one row processed) */
    firstColStart := util.MaxInt(0, l)
    firstColEnd   := util.MaxInt(0, r)

    smithWatermanDp(startRow, endRow, firstColStart, firstColEnd, dpB, dpF, 0, 1, seqPair, wm, gapPenalty, &maxScore)

    /* ---===---  Second step  ---===--- */

    firstColStart += 1
    firstColEnd    = firstColStart + w - 1
    startRow       = endRow + 1
    length        := util.MinInt(len(seqPair.S1) - startRow, len(seqPair.S2) - firstColEnd)
    endRow         = startRow + length - 1

    smithWatermanDp(startRow, endRow, firstColStart, firstColEnd, dpB, dpF, 1, 1, seqPair, wm, gapPenalty, &maxScore)

    /* ---===---  Third step  ---===--- */

    firstColStart += endRow - startRow + 1
    firstColEnd    = len(seqPair.S2) - 1
    startRow       = endRow + 1
    length         = util.MinInt(len(seqPair.S1) - startRow, len(seqPair.S2) - firstColStart)
    endRow         = startRow + length - 1

    smithWatermanDp(startRow, endRow, firstColStart, firstColEnd, dpB, dpF, 1, 0, seqPair, wm, gapPenalty, &maxScore)

    // Return result
    return &AlignResult{
        Score: maxScore,
        Align: "",
    }
}

// Utility function called from inside of smithWatermanStrip().
// Used to remove duplicate code parts.
func smithWatermanDp(
    startRow, endRow, firstStartCol, firstEndCol int, dpB, dpF []int,
    startColIncFactor, endColIncFactor int, /* first step: (0, 1), second step: (1, 1), third step: (1, 0) */
    seqPair *SeqPair, wm *WeightMatrix, gapPenalty int,
    maxScore *int) {

    for row := startRow; row <= endRow; row += 1 {
        startCol := firstStartCol + (row - startRow) * startColIncFactor
        // Clamping by S2 length needed in cases where trip width > S2 length (takes effect in step one)
        endCol   := util.MinInt(len(seqPair.S2) - 1, firstEndCol + (row - startRow) * endColIncFactor)

        for i, col := 1, startCol; col <= endCol; i, col = i + 1, col + 1 {
            dpF[i] = util.Max4(
                0,
                dpF[i - 1]                      + gapPenalty,                     /* left */
                dpB[i      + startColIncFactor] + gapPenalty,                     /* top */
                dpB[i - 1  + startColIncFactor] + seqPair.WeightIn(wm, row, col)) /* top-left */
            *maxScore = util.MaxInt(*maxScore, dpF[i])
        }
        //
        //tab := ""
        //for k := 0; k < startCol; k += 1 {
        //    tab += "    "
        //}
        //fmt.Printf("%-3v | %-2v, %-2v-%-2v: %s%-3v\n", *maxScore, row, startCol, endCol, tab, dpF[1:endCol - startCol + 2])
        //
        copy(dpB, dpF)
    }
}
